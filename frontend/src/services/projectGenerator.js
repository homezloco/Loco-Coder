import { v4 as uuidv4 } from 'uuid';
import { generateProjectName, generateProjectLogo } from './aiService';

// Cache for generated logos to avoid regenerating them
const logoCache = new Map();

/**
 * Service for generating project files and structure
 */
class ProjectGenerator {
  /**
   * Generate project files and structure based on the plan
   * @param {Object} projectInfo - Project information
   * @param {Object} plan - The generated project plan
   * @param {Function} onProgress - Progress callback
   * @returns {Promise<Object>} - Generated project data
   */
  static async generateProject(projectInfo, plan, onProgress = () => {}) {
    try {
      onProgress({ status: 'starting', message: 'Initializing project...' });
      
      // Generate project name if not provided
      const projectName = projectInfo.name || await this._generateProjectName(plan, onProgress);
      
      // Generate project logo
      const logoData = await this._generateProjectLogo(projectName, plan, onProgress);
      
      // Create the base project structure
      const project = {
        ...projectInfo,
        id: projectInfo.id || uuidv4(),
        name: projectName,
        description: projectInfo.description || plan.projectDescription || 'A new project generated by CodeCraft AI',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        metadata: {
          ...projectInfo.metadata,
          generatedAt: new Date().toISOString(),
          version: '1.0.0',
          logo: logoData,
          colorScheme: this._generateColorScheme(projectName)
        },
        files: []
      };

      // Generate files based on the structure
      onProgress({ status: 'generating', message: 'Generating project structure...' });
      
      // Generate files from the structure
      const files = await this._generateFilesFromStructure(plan.structure, '', project.id, onProgress);
      project.files = files;

      // Add README with project information
      const readmeContent = this._generateReadme(project, plan);
      project.files.push({
        id: uuidv4(),
        name: 'README.md',
        path: 'README.md',
        content: readmeContent,
        type: 'file',
        language: 'markdown',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        projectId: project.id
      });

      onProgress({ status: 'success', message: 'Project generated successfully!' });
      return project;
    } catch (error) {
      console.error('Error generating project:', error);
      onProgress({ 
        status: 'error', 
        message: error.message || 'Failed to generate project',
        error 
      });
      throw error;
    }
  }

  /**
   * Recursively generate files from the structure
   * @private
   */
  static async _generateFilesFromStructure(structure, currentPath = '', projectId, onProgress) {
    const files = [];
    
    for (const [name, value] of Object.entries(structure)) {
      const fullPath = currentPath ? `${currentPath}/${name}` : name;
      
      if (value === null || typeof value !== 'object') {
        // This is a file
        const fileContent = this._getDefaultFileContent(name);
        files.push({
          id: uuidv4(),
          name,
          path: fullPath,
          content: fileContent,
          type: 'file',
          language: this._getLanguageFromExtension(name),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          projectId
        });
        
        onProgress({
          status: 'generating',
          message: `Created file: ${fullPath}`,
          current: files.length
        });
      } else {
        // This is a directory
        files.push({
          id: uuidv4(),
          name,
          path: fullPath,
          type: 'directory',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          projectId
        });
        
        // Recursively process directory contents
        const childFiles = await this._generateFilesFromStructure(
          value, 
          fullPath, 
          projectId,
          onProgress
        );
        files.push(...childFiles);
      }
    }
    
    return files;
  }

  /**
   * Generate default content for a file based on its extension
   * @private
   */
  static _getDefaultFileContent(filename) {
    const extension = filename.split('.').pop().toLowerCase();
    
    switch (extension) {
      case 'js':
        return `// ${filename}\n// Generated by CodeCraft AI\n\nconsole.log('Hello, World!');`;
        
      case 'jsx':
        return `import React from 'react';

const ${this._toPascalCase(filename.split('.')[0])} = () => {
  return (
    <div>
      <h1>${filename}</h1>
    </div>
  );
};

export default ${this._toPascalCase(filename.split('.')[0])};`;
        
      case 'css':
        return `/* ${filename} */
/* Generated by CodeCraft AI */\n\n.${filename.split('.')[0].toLowerCase()} {
  /* Your styles here */
}`;
        
      case 'json':
        return `{
  "name": "${filename.split('.')[0].toLowerCase()}",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}`;
        
      default:
        return `# ${filename}\n\nThis file was generated by CodeCraft AI.`;
    }
  }
  
  /**
   * Convert string to PascalCase
   * @private
   */
  static _toPascalCase(str) {
    return str
      .replace(/[^a-zA-Z0-9]+/g, ' ')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  /**
   * Get language from file extension
   * @private
   */
  static _getLanguageFromExtension(filename) {
    const extension = filename.split('.').pop().toLowerCase();
    const languageMap = {
      'js': 'javascript',
      'jsx': 'javascript',
      'ts': 'typescript',
      'tsx': 'typescript',
      'py': 'python',
      'java': 'java',
      'c': 'c',
      'cpp': 'cpp',
      'cs': 'csharp',
      'go': 'go',
      'rb': 'ruby',
      'php': 'php',
      'swift': 'swift',
      'kt': 'kotlin',
      'rs': 'rust',
      'sh': 'shell',
      'html': 'html',
      'css': 'css',
      'scss': 'scss',
      'less': 'less',
      'json': 'json',
      'xml': 'xml',
      'yaml': 'yaml',
      'yml': 'yaml',
      'md': 'markdown',
      'sql': 'sql',
      'dockerfile': 'dockerfile',
      'gitignore': 'gitignore'
    };
    
    return languageMap[extension] || 'plaintext';
  }

  /**
   * Generate README content
   * @private
   */
  static _generateReadme(project, plan) {
    return `# ${project.name}

${project.description || 'A new project generated by CodeCraft AI'}

## Project Structure

${this._formatStructure(plan.structure, 0)}

## Getting Started

### Prerequisites

- Node.js (v14+ recommended)
- npm or yarn

### Installation

\`\`\`bash
# Clone the repository
git clone <repository-url>

# Install dependencies
npm install
\`\`\`

### Available Scripts

- \`npm start\` - Start the development server
- \`npm run build\` - Build for production
- \`npm test\` - Run tests

## Features

${plan.features?.map(feature => `- ${feature}`).join('\n') || '- No features specified'}

## Architecture

${plan.architecture || 'No architecture information available.'}

## Dependencies

${Object.entries(plan.dependencies || {})
  .map(([category, deps]) => `### ${category}\n${deps.map(dep => `- ${dep}`).join('\n')}`)
  .join('\n\n')}

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
`;
  }

  /**
   * Format the project structure as a markdown list
   * @private
   */
  static _formatStructure(structure, level = 0) {
    let result = '';
    const indent = '  '.repeat(level);
    
    for (const [name, value] of Object.entries(structure)) {
      result += `${indent}- ${name}\n`;
      if (value && typeof value === 'object') {
        result += this._formatStructure(value, level + 1);
      }
    }
    
    return result;
  }
  
  /**
   * Generate a project name using AI if not provided
   * @private
   */
  static async _generateProjectName(plan, onProgress) {
    try {
      onProgress({ status: 'generating', message: 'Generating project name...' });
      
      // If we have a project name in the plan, use that
      if (plan.projectName) {
        return plan.projectName;
      }
      
      // Otherwise generate one based on the project description
      const description = plan.projectDescription || 'a new project';
      const name = await generateProjectName(description);
      
      // Update the plan with the generated name
      plan.projectName = name;
      return name;
    } catch (error) {
      console.error('Error generating project name:', error);
      // Fallback to a default name
      return `project-${Date.now()}`;
    }
  }
  
  /**
   * Generate a project logo using AI
   * @private
   */
  static async _generateProjectLogo(projectName, plan, onProgress) {
    try {
      onProgress({ status: 'generating', message: 'Generating project logo...' });
      
      // Check cache first
      const cacheKey = `${projectName}-${plan.projectDescription?.substring(0, 50) || 'default'}`;
      if (logoCache.has(cacheKey)) {
        return logoCache.get(cacheKey);
      }
      
      // Generate logo using AI
      const logoData = await generateProjectLogo(projectName, plan.projectDescription || '');
      
      // Cache the result
      logoCache.set(cacheKey, logoData);
      
      return logoData;
    } catch (error) {
      console.error('Error generating project logo:', error);
      // Return a default logo
      return {
        type: 'svg',
        content: this._generateDefaultLogoSvg(projectName)
      };
    }
  }
  
  /**
   * Generate a default SVG logo with initials
   * @private
   */
  static _generateDefaultLogoSvg(projectName) {
    // Get initials from project name
    const initials = projectName
      .split(/\s+/)
      .map(word => word[0])
      .join('')
      .toUpperCase()
      .substring(0, 3);
    
    // Generate a color based on the project name
    const hue = Array.from(projectName).reduce((acc, char) => acc + char.charCodeAt(0), 0) % 360;
    const color = `hsl(${hue}, 70%, 50%)`;
    
    return `
      <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
        <rect width="200" height="200" rx="40" fill="${color}" opacity="0.8"/>
        <text x="50%" y="50%" 
              font-family="Arial, sans-serif" 
              font-size="80" 
              font-weight="bold"
              fill="white"
              text-anchor="middle"
              dominant-baseline="middle">
          ${initials}
        </text>
      </svg>
    `;
  }
  
  /**
   * Generate a color scheme based on project name
   * @private
   */
  static _generateColorScheme(projectName) {
    // Generate a consistent color based on the project name
    const hash = Array.from(projectName).reduce((acc, char) => acc + char.charCodeAt(0), 0);
    const hue = hash % 360;
    
    return {
      primary: `hsl(${hue}, 70%, 50%)`,
      secondary: `hsl(${(hue + 30) % 360}, 70%, 50%)`,
      accent: `hsl(${(hue + 180) % 360}, 70%, 50%)`,
      background: '#1a1a1a',
      surface: '#2d2d2d',
      text: '#ffffff'
    };
  }
}

export default ProjectGenerator;

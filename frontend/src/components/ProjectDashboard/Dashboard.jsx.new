import React, { useState, useEffect, useCallback, useRef } from 'react';
import { 
  checkApiHealth, 
  fetchProjects, 
  toggleProjectFavorite, 
  deleteProject, 
  searchProjects, 
  persistProjects 
} from './projectUtils';
import * as projectUtils from './projectUtils';
import ProjectGrid from './ProjectGrid';
import ProjectFilters from './ProjectFilters';
import PersistenceStatus from './PersistenceStatus';
import DashboardControls from './DashboardControls';
import LoadingState from './LoadingState';
import ErrorState from './ErrorState';
import EmptyState from './EmptyState';
import SyncIndicator from './SyncIndicator';

// Modal for delete confirmation
const DeleteConfirmationModal = ({ project, onDelete, onCancel, isDarkMode }) => (
  <div style={{
    backgroundColor: isDarkMode ? '#1e2030' : 'white',
    padding: '24px',
    borderRadius: '8px',
    width: '400px',
    maxWidth: '90%',
    boxShadow: '0 4px 20px rgba(0,0,0,0.15)'
  }}>
    <h3 style={{ margin: '0 0 16px', color: isDarkMode ? '#e8ecf3' : '#2c3e50' }}>
      Delete Project
    </h3>
    <p style={{ color: isDarkMode ? '#a9b3cc' : '#64748b' }}>
      Are you sure you want to delete <strong>{project.name}</strong>? This cannot be undone.
    </p>
    <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '12px', marginTop: '24px' }}>
      <button 
        onClick={onCancel}
        style={{
          padding: '8px 16px',
          borderRadius: '4px',
          border: isDarkMode ? '1px solid #4b5563' : '1px solid #e2e8f0',
          background: 'transparent',
          color: isDarkMode ? '#e2e8f0' : '#4b5563',
          cursor: 'pointer'
        }}
      >
        Cancel
      </button>
      <button 
        onClick={onDelete}
        style={{
          padding: '8px 16px',
          borderRadius: '4px',
          border: 'none',
          background: '#ef4444',
          color: 'white',
          cursor: 'pointer'
        }}
      >
        Delete
      </button>
    </div>
  </div>
);

/**
 * Main ProjectDashboard component with comprehensive fallbacks
 * Modularized for better maintainability and organization
 */
const Dashboard = ({ 
  isVisible = true, 
  onClose, 
  onProjectSelect,
  isDarkMode = false,
  apiEndpoint = 'http://localhost:5000/api'
}) => {
  // State management
  const [projects, setProjects] = useState([]);
  const [filteredProjects, setFilteredProjects] = useState([]);
  const [selectedProjectId, setSelectedProjectId] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [activeFilter, setActiveFilter] = useState('all');
  const [isCustomizing, setIsCustomizing] = useState(false);
  const [layoutMode, setLayoutMode] = useState('grid');
  const [dataSource, setDataSource] = useState('loading');
  const [apiStatus, setApiStatus] = useState({ status: 'checking', message: 'Checking connection...' });
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  const [projectToDelete, setProjectToDelete] = useState(null);
  const [isSyncing, setIsSyncing] = useState(false);
  const [lastSyncTime, setLastSyncTime] = useState(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [snackbar, setSnackbar] = useState({ visible: false, message: '', type: 'info' });
  
  // Refs
  const dashboardRef = useRef(null);
  
  // Effect to focus dashboard on mount for keyboard shortcuts
  useEffect(() => {
    if (dashboardRef.current) {
      dashboardRef.current.focus();
    }
  }, []);
  
  // Initialize from localStorage/preferences
  useEffect(() => {
    // Check for saved layout mode
    const savedLayoutMode = localStorage.getItem('dashboardLayoutMode');
    if (savedLayoutMode) {
      setLayoutMode(savedLayoutMode);
    }
    
    // Check for customization mode
    const isCustomizing = localStorage.getItem('dashboardCustomizing') === 'true';
    setIsCustomizing(isCustomizing);
    
    // Check for last known API status
    const lastKnownStatus = localStorage.getItem('lastKnownApiStatus');
    if (lastKnownStatus) {
      setApiStatus(prev => ({ ...prev, status: lastKnownStatus }));
    }
    
    // Check for last sync time
    const storedSyncTime = localStorage.getItem('projectsLastSyncTime');
    if (storedSyncTime) {
      setLastSyncTime(parseInt(storedSyncTime, 10));
    }
  }, []);
  
  // Load projects with robust multi-tiered fallback
  const loadProjects = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      console.log('Loading projects...');
      
      // Check API health first (silently, to avoid redundant notifications)
      const apiHealth = await checkApiHealth(apiEndpoint, true);
      console.log('API health check result:', apiHealth);
      
      // Attempt to load projects with multi-tiered fallback
      const result = await fetchProjects(apiEndpoint, {
        quiet: true, // Suppress console errors during fetch
        filter: activeFilter !== 'all' ? activeFilter : null,
        search: searchQuery || null
      });
      
      console.log('Projects loaded from source:', result.source);
      console.log(`Found ${result.projects.length} projects`);
      
      // Update projects state
      setProjects(result.projects);
      
      // Apply filters to the loaded projects
      let filtered = [...result.projects];
      
      // Apply tag/type filter if active
      if (activeFilter !== 'all') {
        filtered = filtered.filter(project => {
          if (activeFilter === 'favorite') return project.favorite;
          if (activeFilter === 'recent') return true; // We'll sort by date below
          return project.tags?.includes(activeFilter) || project.type === activeFilter;
        });
      }
      
      // Apply search filter if present
      if (searchQuery) {
        filtered = searchProjects(filtered, searchQuery);
      }
      
      // Sort by relevance if searching, otherwise by recency
      if (searchQuery) {
        // Search results are already sorted by relevance by the searchProjects function
      } else if (activeFilter === 'recent') {
        // Sort by last accessed for recent view
        filtered.sort((a, b) => (b.lastAccessed || 0) - (a.lastAccessed || 0));
      } else {
        // Default sort by creation date, newest first
        filtered.sort((a, b) => (b.created || 0) - (a.created || 0));
      }
      
      setFilteredProjects(filtered);
      setDataSource(result.source);
      setError(null);
      
      // Handle different data sources with appropriate UI feedback
      if (result.source === 'API') {
        // API is online and working
        const now = Date.now();
        setLastSyncTime(now);
        localStorage.setItem('projectsLastSyncTime', now.toString());
        
        // Update API status
        setApiStatus({ 
          status: 'online', 
          message: 'Connected to API' 
        });
        localStorage.setItem('lastKnownApiStatus', 'online');
      } else if (result.source === 'IndexedDB') {
        // Using IndexedDB (API is offline but we have stored data)
        setApiStatus({ 
          status: 'degraded', 
          message: 'Limited connectivity - using stored data' 
        });
        localStorage.setItem('lastKnownApiStatus', 'degraded');
        
        // Show notification
        setSnackbar({
          visible: true,
          message: 'Working offline with cached projects. Changes will sync when you reconnect.',
          type: 'warning'
        });
      } else if (result.source === 'localStorage' || result.source === 'sessionStorage') {
        // Using simple storage as backup
        setApiStatus({ 
          status: 'degraded', 
          message: 'Limited connectivity - using simple storage' 
        });
        localStorage.setItem('lastKnownApiStatus', 'degraded');
        
        // Show notification
        setSnackbar({
          visible: true,
          message: 'Working with limited storage. Some features may be unavailable.',
          type: 'warning'
        });
      } else {
        // Using demo data (ultimate fallback)
        setApiStatus({ status: 'offline', message: 'No connection - using demo data' });
        localStorage.setItem('lastKnownApiStatus', 'offline');
        
        // Show notification
        setSnackbar({
          visible: true,
          message: 'Working offline with demo projects. Changes will not be saved.',
          type: 'error'
        });
      }
    } catch (error) {
      console.error('Failed to load projects:', error);
      setError(error.message);
      setApiStatus({ status: 'error', message: 'Error loading projects' });
      
      setSnackbar({
        visible: true,
        message: `Error loading projects: ${error.message}`,
        type: 'error'
      });
    } finally {
      setIsLoading(false);
    }
  }, [activeFilter, searchQuery, apiStatus, apiEndpoint]);
  
  // Manual sync function to fetch fresh data from API
  const syncWithAPI = async () => {
    try {
      setIsSyncing(true);
      setSnackbar({
        visible: true,
        message: 'Syncing projects with server...',
        type: 'info'
      });
      
      // First check if API is reachable
      const apiHealth = await checkApiHealth(apiEndpoint);
      
      if (apiHealth.status !== 'online') {
        // API is not available, show error
        setSnackbar({
          visible: true,
          message: 'Cannot sync - API is not available. Check your connection.',
          type: 'error'
        });
        setIsSyncing(false);
        return;
      }
      
      // API is available, get latest projects
      const response = await fetch(`${apiEndpoint}/projects`);
      
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      
      const freshProjects = await response.json();
      
      // Get local projects to determine what's changed
      const localProjects = projects;
      
      // Compare and merge projects
      const mergedProjects = projectUtils.mergeProjects(freshProjects, localProjects);
      
      // Update state with merged projects
      setProjects(mergedProjects);
      
      // Re-apply filters
      let filtered = [...mergedProjects];
      
      if (activeFilter !== 'all') {
        filtered = filtered.filter(project => {
          if (activeFilter === 'favorite') return project.favorite;
          if (activeFilter === 'recent') return true;
          return project.tags?.includes(activeFilter) || project.type === activeFilter;
        });
      }
      
      if (searchQuery) {
        filtered = searchProjects(filtered, searchQuery);
      }
      
      // Update filtered projects
      setFilteredProjects(filtered);
      
      // Update API status
      setApiStatus({ status: 'online', message: 'Connected to API' });
      
      // Update data source
      setDataSource('API');
      
      // Update last sync time
      const now = Date.now();
      setLastSyncTime(now);
      localStorage.setItem('projectsLastSyncTime', now.toString());
      
      // Persist merged projects to all storage layers
      persistProjects(mergedProjects);
      
      // Show success notification
      setSnackbar({
        visible: true,
        message: 'Projects synced successfully!',
        type: 'success'
      });
    } catch (error) {
      console.error('Failed to sync projects:', error);
      
      setSnackbar({
        visible: true,
        message: `Sync failed: ${error.message}`,
        type: 'error'
      });
    } finally {
      setIsSyncing(false);
    }
  };
  
  // Handle project selection
  const handleSelectProject = (project) => {
    setSelectedProjectId(project.id);
    if (onProjectSelect) {
      onProjectSelect(project);
    }
  };
  
  // Handle project order change from drag-and-drop
  const handleProjectOrderChange = (reorderedProjects) => {
    // Update projects array with new order
    setProjects(reorderedProjects);
    setFilteredProjects(reorderedProjects);
    
    // Persist the new order
    persistProjects(reorderedProjects);
  };
  
  // Toggle customization mode with persistence
  const toggleCustomizing = () => {
    setIsCustomizing(prev => {
      const newValue = !prev;
      
      // Persist user preference
      localStorage.setItem('dashboardCustomizing', newValue.toString());
      
      // Show feedback to user
      setSnackbar({
        visible: true,
        message: newValue 
          ? 'Customization mode enabled. You can now reorder projects.' 
          : 'Customization mode disabled. Changes saved.',
        type: 'info'
      });
      
      return newValue;
    });
  };
  
  // Change dashboard layout mode with multi-tiered persistence
  const changeLayoutMode = (mode) => {
    if (mode === layoutMode) return;
    
    setLayoutMode(mode);
    
    // Persist user preference
    try {
      localStorage.setItem('dashboardLayoutMode', mode);
      
      // Show feedback to user
      setSnackbar({
        visible: true,
        message: `Layout changed to ${mode} view`,
        type: 'info'
      });
    } catch (error) {
      console.error('Failed to persist layout mode:', error);
    }
  };
  
  // Open delete confirmation modal
  const openDeleteConfirmation = (projectId, projectName) => {
    const project = projects.find(p => p.id === projectId);
    setProjectToDelete(project);
    setIsDeleteModalOpen(true);
  };
  
  // Handle project selection with multi-tiered persistence
  const handleProjectSelect = (projectId) => {
    setSelectedProjectId(projectId);
    
    if (onProjectSelect) {
      const selectedProject = projects.find(p => p.id === projectId);
      
      if (selectedProject) {
        // Update last accessed timestamp
        const updatedProject = {
          ...selectedProject,
          lastAccessed: Date.now()
        };
        
        // Update in local state
        const updatedProjects = projects.map(p => 
          p.id === projectId ? updatedProject : p
        );
        
        setProjects(updatedProjects);
        
        // Persist updated projects
        persistProjects(updatedProjects);
        
        // Call the callback
        onProjectSelect(updatedProject);
      }
    }
  };
  
  // Handle project deletion
  const handleDeleteProject = async () => {
    if (!projectToDelete) return;
    
    try {
      setIsLoading(true);
      
      // Attempt to delete from the server if API is available
      if (apiStatus.status === 'online') {
        await deleteProject(projectToDelete.id, apiEndpoint);
      }
      
      // Remove from local state regardless of API status
      const updatedProjects = projects.filter(p => p.id !== projectToDelete.id);
      setProjects(updatedProjects);
      
      // Update filtered projects
      setFilteredProjects(prev => prev.filter(p => p.id !== projectToDelete.id));
      
      // Persist to all storage layers
      persistProjects(updatedProjects);
      
      // Show feedback
      setSnackbar({
        visible: true,
        message: `Project "${projectToDelete.name}" was deleted`,
        type: 'success'
      });
      
      // Close modal
      setIsDeleteModalOpen(false);
      setProjectToDelete(null);
    } catch (error) {
      console.error('Failed to delete project:', error);
      
      setSnackbar({
        visible: true,
        message: `Failed to delete project: ${error.message}`,
        type: 'error'
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  // Handle dashboard close
  const handleClose = () => {
    if (onClose) {
      onClose();
    }
  };
  
  // Handle new project creation
  const handleCreateProject = async () => {
    try {
      // Generate a new project with default values
      const newId = `project-${Date.now()}`;
      const now = Date.now();
      const newProject = {
        id: newId,
        name: `New Project ${projects.length + 1}`,
        description: 'Click to edit project description',
        created: now,
        updated: now,
        lastAccessed: now,
        favorite: false,
        type: 'general',
        tags: ['new'],
        status: 'active',
        thumbnail: null,
      };
      
      // Add to local state first for immediate feedback
      const updatedProjects = [newProject, ...projects];
      setProjects(updatedProjects);
      
      // Update filtered projects
      if (activeFilter === 'all' || activeFilter === 'recent' || 
          newProject.tags.includes(activeFilter) || newProject.type === activeFilter) {
        setFilteredProjects(prev => [newProject, ...prev]);
      }
      
      // Persist to all storage layers
      await persistProjects(updatedProjects);
      
      // Show feedback
      setSnackbar({
        visible: true,
        message: 'New project created',
        type: 'success'
      });
      
      // If API is online, try to sync with server
      if (apiStatus.status === 'online') {
        try {
          // In a real app, we would POST to API here
          console.log('Syncing new project to API would happen here');
        } catch (error) {
          console.warn('Failed to sync new project to API:', error);
        }
      }
      
      return newProject;
    } catch (error) {
      console.error('Failed to create new project:', error);
      setSnackbar({
        visible: true,
        message: `Failed to create project: ${error.message}`,
        type: 'error'
      });
    }
  };

  // Only render if visible
  if (!isVisible) {
    return null;
  }
  
  // Auto-hide snackbar after a delay
  useEffect(() => {
    if (snackbar.visible) {
      const timer = setTimeout(() => {
        setSnackbar({ ...snackbar, visible: false });
      }, 5000); // 5 seconds
      
      return () => clearTimeout(timer);
    }
  }, [snackbar]);
  
  // Load projects on initial render and when filter changes
  useEffect(() => {
    loadProjects();
  }, [loadProjects, activeFilter, searchQuery]);
  
  // Keyboard shortcuts
  const handleKeyPress = (e) => {
    if (e.key === 'Escape') {
      handleClose();
    } else if (e.ctrlKey && e.key === 'n') {
      e.preventDefault();
      handleCreateProject();
    } else if (e.ctrlKey && e.key === 's') {
      e.preventDefault();
      syncWithAPI();
    } else if (e.ctrlKey && e.key === 'c') {
      e.preventDefault();
      toggleCustomizing();
    }
  };
  
  return (
    <div 
      ref={dashboardRef}
      className="project-dashboard"
      tabIndex="0"
      onKeyDown={handleKeyPress}
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100vw',
        height: '100vh',
        backgroundColor: isDarkMode ? 'rgba(30, 30, 30, 0.9)' : 'rgba(255, 255, 255, 0.9)',
        backdropFilter: 'blur(5px)',
        display: 'flex',
        flexDirection: 'column',
        padding: '24px',
        zIndex: 1000, // High z-index to ensure visibility
        boxSizing: 'border-box',
        overflowY: 'auto',
        color: isDarkMode ? '#e8ecf3' : '#2c3e50',
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif',
        visibility: 'visible !important', // Force visibility
        opacity: 1
      }}
    >
      <header className="dashboard-header" style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '24px',
        borderBottom: isDarkMode ? '1px solid #2d3348' : '1px solid #edf2f7',
        paddingBottom: '16px'
      }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <h2 style={{ 
            margin: 0, 
            fontSize: '26px',
            fontWeight: '600',
            color: isDarkMode ? '#e8ecf3' : '#2c3e50',
            display: 'flex',
            alignItems: 'center',
            gap: '10px'
          }}>
            <span role="img" aria-hidden="true" style={{fontSize: '24px'}}>📁</span>
            Projects
          </h2>
          
          {/* API Status indicator */}
          <div style={{
            display: 'flex',
            alignItems: 'center',
            gap: '8px',
            backgroundColor: isDarkMode ? '#2d334820' : '#f8fafc',
            padding: '6px 12px',
            borderRadius: '16px',
            fontSize: '13px'
          }}>
            <div className="status-indicator" style={{
              width: '8px',
              height: '8px',
              borderRadius: '50%',
              backgroundColor: apiStatus?.status === 'online' ? '#10B981' :
                              apiStatus?.status === 'degraded' ? '#F59E0B' : '#EF4444',
              boxShadow: apiStatus?.status === 'online' ? '0 0 6px rgba(16, 185, 129, 0.6)' :
                        apiStatus?.status === 'degraded' ? '0 0 6px rgba(245, 158, 11, 0.6)' : 
                        '0 0 6px rgba(239, 68, 68, 0.6)',
            }}></div>
            <span className="status-text" style={{ 
              color: isDarkMode ? '#a9b3cc' : '#5a6682',
              fontWeight: '500',
            }}>
              {apiStatus?.status === 'online' ? 'API Connected' : 
              apiStatus?.status === 'degraded' ? 'Limited Connectivity' : 
              'API Offline'}
            </span>
            
            <div style={{
              display: 'flex',
              alignItems: 'center',
              gap: '5px',
              color: isDarkMode ? '#8a96b0' : '#94a3b8',
              fontSize: '12px',
              marginLeft: '5px',
              borderLeft: isDarkMode ? '1px solid #3d4663' : '1px solid #e2e8f0',
              paddingLeft: '8px'
            }}>
              <span>Source: {dataSource}</span>
              <SyncIndicator 
                isSyncing={isSyncing} 
                lastSyncTime={lastSyncTime} 
                onSync={syncWithAPI} 
                isDarkMode={isDarkMode} 
              />
            </div>
          </div>
        </div>
        
        {/* Dashboard controls */}
        <DashboardControls 
          onClose={handleClose}
          onCreateProject={handleCreateProject}
          isCustomizing={isCustomizing}
          onToggleCustomizing={toggleCustomizing}
          layoutMode={layoutMode}
          onChangeLayout={changeLayoutMode}
          isDarkMode={isDarkMode}
          onSearchChange={setSearchQuery}
          searchQuery={searchQuery}
        />
      </header>
      
      {/* Filters */}
      <ProjectFilters 
        activeFilter={activeFilter}
        onFilterChange={setActiveFilter}
        isDarkMode={isDarkMode}
      />

      {/* Main content area */}
      {isLoading ? (
        <LoadingState isDarkMode={isDarkMode} message="Loading projects..." />
      ) : error ? (
        <ErrorState 
          error={error} 
          isDarkMode={isDarkMode}
          onRetry={loadProjects}
        />
      ) : filteredProjects.length > 0 ? (
        <ProjectGrid
          projects={filteredProjects}
          onSelectProject={handleSelectProject}
          onDeleteProject={openDeleteConfirmation}
          onToggleFavorite={projectId => {
            const updatedProjects = projects.map(p => 
              p.id === projectId ? { ...p, favorite: !p.favorite } : p
            );
            setProjects(updatedProjects);
            setFilteredProjects(prev => 
              prev.map(p => p.id === projectId ? { ...p, favorite: !p.favorite } : p)
            );
            toggleProjectFavorite(projectId);
          }}
          selectedProjectId={selectedProjectId}
          isCustomizing={isCustomizing}
          onProjectOrderChange={handleProjectOrderChange}
          layoutMode={layoutMode}
          isDarkMode={isDarkMode}
        />
      ) : filteredProjects.length === 0 && searchQuery ? (
        <div style={{
          padding: '40px',
          textAlign: 'center',
          color: isDarkMode ? '#aaa' : '#666'
        }}>
          <h3>No matching projects</h3>
          <p>Try adjusting your search or filters</p>
        </div>
      ) : (
        <EmptyState 
          onCreateProject={handleCreateProject}
          isDarkMode={isDarkMode}
          searchQuery={searchQuery}
          onResetSearch={() => setSearchQuery('')}
        />
      )}
      
      {/* Status snackbar */}
      {snackbar.visible && (
        <div style={{
          position: 'fixed',
          bottom: '20px',
          left: '50%',
          transform: 'translateX(-50%)',
          backgroundColor: snackbar.type === 'error' ? '#d32f2f' : 
                          snackbar.type === 'warning' ? '#f57c00' : 
                          snackbar.type === 'success' ? '#388e3c' : '#1976d2',
          color: '#fff',
          padding: '10px 20px',
          borderRadius: '4px',
          boxShadow: '0 2px 5px rgba(0,0,0,0.2)',
          zIndex: 1200,
          maxWidth: '80%',
          textAlign: 'center'
        }}>
          {snackbar.message}
        </div>
      )}
      
      {/* Delete confirmation modal */}
      {isDeleteModalOpen && projectToDelete && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          width: '100vw',
          height: '100vh',
          backgroundColor: 'rgba(0, 0, 0, 0.5)',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 1200
        }}>
          <DeleteConfirmationModal 
            project={projectToDelete}
            onDelete={handleDeleteProject}
            onCancel={() => setIsDeleteModalOpen(false)}
            isDarkMode={isDarkMode}
          />
        </div>
      )}
    </div>
  );
};

export default Dashboard;

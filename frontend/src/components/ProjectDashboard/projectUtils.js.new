/**
 * Project Dashboard Utility Functions with Persistence Monitoring
 *
 * Multi-tiered fallback system with performance monitoring:
 * 1. API (primary source when online)
 * 2. IndexedDB (persistent offline storage)
 * 3. localStorage (simpler persistent storage)
 * 4. sessionStorage (temporary session storage)
 * 5. Demo projects (ultimate fallback)
 */

// Import services dynamically to reduce initial load time
import * as persistenceMonitor from '../../utils/persistenceMonitor';

// Demo projects as fallback data
export const DEMO_PROJECTS = [
  {
    id: 'demo1',
    name: 'React Weather App',
    description: 'A weather application built with React and OpenWeatherMap API',
    language: 'javascript',
    type: 'frontend',
    lastModified: new Date(Date.now() - 86400000).toISOString(),
    favorite: true,
    tags: ['react', 'api', 'weather']
  },
  {
    id: 'demo2',
    name: 'Express REST API',
    description: 'RESTful API built with Express and MongoDB',
    language: 'javascript',
    type: 'backend',
    lastModified: new Date(Date.now() - 172800000).toISOString(),
    favorite: false,
    tags: ['express', 'mongodb', 'rest']
  },
  {
    id: 'demo3',
    name: 'Django Blog',
    description: 'Full-featured blog application with Django',
    language: 'python',
    type: 'fullstack',
    lastModified: new Date(Date.now() - 259200000).toISOString(),
    favorite: false,
    tags: ['django', 'python', 'web']
  },
  {
    id: 'demo4',
    name: 'Flutter Mobile App',
    description: 'Cross-platform mobile app with Flutter',
    language: 'dart',
    type: 'mobile',
    lastModified: new Date(Date.now() - 345600000).toISOString(),
    favorite: true,
    tags: ['flutter', 'mobile', 'dart']
  },
  {
    id: 'demo5',
    name: 'FastAPI Microservice',
    description: 'High-performance API with FastAPI',
    language: 'python',
    type: 'backend',
    lastModified: new Date(Date.now() - 432000000).toISOString(),
    favorite: false,
    tags: ['fastapi', 'python', 'microservice']
  }
];

/**
 * Load IndexedDB service dynamically
 * @returns {Promise<Object|null>} IndexedDB service or null if unavailable
 */
const getIndexedDBService = async () => {
  try {
    const startTime = performance.now();
    const module = await import('../../utils/indexedDBService');
    const isAvailable = await module.isIndexedDBAvailable();
    const responseTime = performance.now() - startTime;
    
    persistenceMonitor.recordStorageOperation('indexedDB', isAvailable, responseTime);
    
    return isAvailable ? module.default : null;
  } catch (error) {
    console.error('Failed to load IndexedDB service:', error);
    persistenceMonitor.recordStorageOperation('indexedDB', false);
    return null;
  }
};

/**
 * Check API health with multiple fallback mechanisms
 * @param {string} apiEndpoint - The base API URL to check
 * @param {boolean} quiet - Whether to suppress console errors (for expected offline mode)
 * @returns {Object} Status object with status and message
 */
export const checkApiHealth = async (apiEndpoint, quiet = false) => {
  try {
    // Try primary health check endpoint
    const response = await fetch(`${apiEndpoint}/health`, {
      method: 'GET',
      headers: { 'Accept': 'application/json' },
      signal: AbortSignal.timeout(3000) // 3-second timeout
    });
    
    if (response.ok) {
      return { status: 'online', message: 'API is online and responding normally' };
    }
    
    // First fallback - try alternative health check endpoint
    try {
      const altResponse = await fetch(`${apiEndpoint}/status`, {
        method: 'GET',
        signal: AbortSignal.timeout(2000)
      });
      
      if (altResponse.ok) {
        return { status: 'online', message: 'API is online via secondary endpoint' };
      }
    } catch {
      // Continue to next fallback
    }
    
    // Second fallback - ping basic endpoint
    try {
      const basicResponse = await fetch(apiEndpoint, {
        method: 'HEAD',
        signal: AbortSignal.timeout(2000)
      });
      
      if (basicResponse.ok || basicResponse.status < 500) {
        return { status: 'degraded', message: 'API is responding but may have limited functionality' };
      }
    } catch {
      // Final fallback - consider offline
    }
    
    if (!quiet) {
      console.log('API health check complete: API appears to be offline');
    }
    return { status: 'offline', message: 'API appears to be offline' };
    
  } catch (error) {
    // Only log errors if not in quiet mode (expected failures shouldn't flood console)
    if (!quiet) {
      if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
        console.log('API unreachable - switching to offline mode');
      } else {
        console.warn('API health check failed:', error.message);
      }
    }
    return { status: 'offline', message: 'API unavailable - using offline mode' };
  }
};

/**
 * Fetch projects with comprehensive fallbacks
 * @param {string} apiEndpoint - API endpoint to fetch from
 * @param {boolean} quiet - Whether to suppress expected errors in console
 * @returns {Object} Result containing projects, source, and any errors
 */
export const fetchProjects = async (apiEndpoint, quiet = false) => {
  let projects = [];
  let errorMessage = null;
  let source = null;
  
  try {
    // Check API health first (pass quiet flag to reduce console noise)
    const apiHealth = await checkApiHealth(apiEndpoint, quiet);
    const apiIsHealthy = apiHealth.status !== 'offline';
    
    // Try API first if it's available
    if (apiIsHealthy) {
      try {
        const apiStartTime = performance.now();
        const response = await fetch(`${apiEndpoint}/projects`, { 
          signal: AbortSignal.timeout(5000) // 5-second timeout
        });
        const apiResponseTime = performance.now() - apiStartTime;
        
        if (response.ok) {
          const data = await response.json();
          if (Array.isArray(data) && data.length > 0) {
            projects = data;
            source = 'API';
            // Cache to localStorage for future use
            localStorage.setItem('cachedProjects', JSON.stringify(projects));
            localStorage.setItem('projectsCacheTime', Date.now());
            
            // Record successful API operation
            persistenceMonitor.recordStorageOperation('api', true, apiResponseTime);
            persistenceMonitor.recordDataSource('API');
            
            return { projects, source, error: null };
          }
        }
        
        // API request completed but didn't return valid data
        persistenceMonitor.recordStorageOperation('api', false, apiResponseTime);
      } catch (apiError) {
        console.warn('API fetch failed, using fallbacks:', apiError.message);
        errorMessage = `API Error: ${apiError.message}`;
        persistenceMonitor.recordStorageOperation('api', false);
      }
    }
    
    // Try IndexedDB fallback
    persistenceMonitor.recordFallback('apiToIndexedDB');
    
    const indexedDBService = await getIndexedDBService();
    if (indexedDBService) {
      try {
        const indexedDBStartTime = performance.now();
        const indexedDBProjects = await indexedDBService.getAllProjects();
        const indexedDBResponseTime = performance.now() - indexedDBStartTime;
        
        if (indexedDBProjects && indexedDBProjects.length > 0) {
          console.log(`Loaded ${indexedDBProjects.length} projects from IndexedDB`);
          
          // Record successful IndexedDB operation
          persistenceMonitor.recordStorageOperation('indexedDB', true, indexedDBResponseTime);
          persistenceMonitor.recordDataSource('IndexedDB');
          
          return { 
            projects: indexedDBProjects, 
            source: 'IndexedDB', 
            error: errorMessage 
          };
        }
        persistenceMonitor.recordStorageOperation('indexedDB', false, indexedDBResponseTime);
      } catch (indexedDBError) {
        console.warn('IndexedDB fallback failed:', indexedDBError);
        errorMessage = errorMessage || `IndexedDB Error: ${indexedDBError.message}`;
        persistenceMonitor.recordStorageOperation('indexedDB', false);
      }
    }
    
    // Try localStorage fallback
    persistenceMonitor.recordFallback('indexedDBToLocalStorage');
    
    try {
      const localStorageStartTime = performance.now();
      const cachedProjectsString = localStorage.getItem('cachedProjects');
      if (cachedProjectsString) {
        const cachedProjects = JSON.parse(cachedProjectsString);
        if (Array.isArray(cachedProjects) && cachedProjects.length > 0) {
          console.log(`Loaded ${cachedProjects.length} projects from localStorage`);
          
          // Record successful localStorage operation
          persistenceMonitor.recordStorageOperation('localStorage', true);
          persistenceMonitor.recordDataSource('localStorage');
          
          return { 
            projects: cachedProjects, 
            source: 'localStorage', 
            error: errorMessage 
          };
        }
      }
      persistenceMonitor.recordStorageOperation('localStorage', false);
    } catch (localStorageError) {
      console.warn('localStorage fallback failed:', localStorageError);
      errorMessage = errorMessage || `localStorage Error: ${localStorageError.message}`;
      persistenceMonitor.recordStorageOperation('localStorage', false);
    }
    
    // Try sessionStorage fallback
    persistenceMonitor.recordFallback('localStorageToSessionStorage');
    
    try {
      const sessionStorageStartTime = performance.now();
      const sessionProjectsString = sessionStorage.getItem('cachedProjects');
      if (sessionProjectsString) {
        const sessionProjects = JSON.parse(sessionProjectsString);
        if (Array.isArray(sessionProjects) && sessionProjects.length > 0) {
          console.log(`Loaded ${sessionProjects.length} projects from sessionStorage`);
          
          // Record successful sessionStorage operation
          persistenceMonitor.recordStorageOperation('sessionStorage', true);
          persistenceMonitor.recordDataSource('sessionStorage');
          
          return { 
            projects: sessionProjects, 
            source: 'sessionStorage', 
            error: errorMessage 
          };
        }
      }
      persistenceMonitor.recordStorageOperation('sessionStorage', false);
    } catch (sessionStorageError) {
      console.warn('sessionStorage fallback failed:', sessionStorageError);
      errorMessage = errorMessage || `sessionStorage Error: ${sessionStorageError.message}`;
      persistenceMonitor.recordStorageOperation('sessionStorage', false);
    }
    
    // Final fallback - use demo data
    persistenceMonitor.recordFallback('toDemo');
    persistenceMonitor.recordDataSource('demoData');
    
    console.log('All persistence methods failed, using demo data');
    return { 
      projects: DEMO_PROJECTS, 
      source: 'demoData', 
      error: errorMessage || 'All persistence methods failed' 
    };
  } catch (criticalError) {
    console.error('Critical error in project fetching:', criticalError);
    return { 
      projects: DEMO_PROJECTS, 
      source: 'demoData (after error)', 
      error: `Critical error: ${criticalError.message}` 
    };
  }
};

/**
 * Filter projects based on active filter
 * @param {Array} projects - Array of projects to filter
 * @param {string} activeFilter - Filter to apply
 * @returns {Array} - Filtered projects
 */
export const filterProjects = (projects, activeFilter) => {
  if (!projects || !Array.isArray(projects)) return [];
  
  switch (activeFilter) {
    case 'recent':
      // Sort by last modified, newest first
      return [...projects].sort(
        (a, b) => new Date(b.lastModified) - new Date(a.lastModified)
      ).slice(0, 10); // Only show 10 most recent
      
    case 'favorites':
      return projects.filter(project => project.favorite);
      
    case 'frontend':
      return projects.filter(project => project.type === 'frontend');
      
    case 'backend':
      return projects.filter(project => project.type === 'backend');
      
    case 'fullstack':
      return projects.filter(project => project.type === 'fullstack');
      
    case 'all':
    default:
      return projects;
  }
};

/**
 * Search projects by name, description, or tags
 * @param {Array} projects - Array of projects to search
 * @param {string} query - Search query
 * @returns {Array} - Filtered projects matching the search query
 */
export const searchProjects = (projects, query) => {
  if (!projects || !Array.isArray(projects) || !query) return projects;
  
  const normalizedQuery = query.toLowerCase().trim();
  if (!normalizedQuery) return projects;
  
  return projects.filter(project => {
    // Search in name and description
    const nameMatch = project.name && project.name.toLowerCase().includes(normalizedQuery);
    const descMatch = project.description && project.description.toLowerCase().includes(normalizedQuery);
    
    // Search in tags if they exist
    let tagMatch = false;
    if (project.tags && Array.isArray(project.tags)) {
      tagMatch = project.tags.some(tag => 
        tag.toLowerCase().includes(normalizedQuery)
      );
    }
    
    // Search in language if available
    const langMatch = project.language && project.language.toLowerCase().includes(normalizedQuery);
    
    return nameMatch || descMatch || tagMatch || langMatch;
  });
};

/**
 * Persist projects to multiple storage mechanisms
 * @param {Array} projects - Array of projects to persist
 * @returns {Promise<boolean>} - True if persisted successfully to at least one storage mechanism
 */
export const persistProjects = async (projects) => {
  if (!Array.isArray(projects) || projects.length === 0) {
    console.warn('No projects to persist');
    return false;
  }
  
  let persistedSuccessfully = false;
  
  // Try IndexedDB first
  try {
    const indexedDBStartTime = performance.now();
    const indexedDBService = await getIndexedDBService();
    if (indexedDBService) {
      const result = await indexedDBService.storeProjects(projects);
      const indexedDBResponseTime = performance.now() - indexedDBStartTime;
      
      if (result) {
        console.log(`Successfully stored ${projects.length} projects in IndexedDB`);
        persistedSuccessfully = true;
        persistenceMonitor.recordStorageOperation('indexedDB', true, indexedDBResponseTime);
      } else {
        persistenceMonitor.recordStorageOperation('indexedDB', false, indexedDBResponseTime);
      }
    }
  } catch (indexedDBError) {
    console.warn('Failed to persist to IndexedDB:', indexedDBError);
    persistenceMonitor.recordStorageOperation('indexedDB', false);
  }
  
  // Fallback to localStorage
  try {
    const localStorageStartTime = performance.now();
    localStorage.setItem('cachedProjects', JSON.stringify(projects));
    localStorage.setItem('projectsCacheTime', Date.now());
    console.log(`Cached ${projects.length} projects to localStorage`);
    persistedSuccessfully = true;
    persistenceMonitor.recordStorageOperation('localStorage', true);
  } catch (localStorageError) {
    console.warn('Failed to persist to localStorage:', localStorageError);
    persistenceMonitor.recordStorageOperation('localStorage', false);
  }
  
  // Additional fallback to sessionStorage
  try {
    const sessionStorageStartTime = performance.now();
    sessionStorage.setItem('cachedProjects', JSON.stringify(projects));
    console.log(`Cached ${projects.length} projects to sessionStorage`);
    persistedSuccessfully = true;
    persistenceMonitor.recordStorageOperation('sessionStorage', true);
  } catch (sessionStorageError) {
    console.warn('Failed to persist to sessionStorage:', sessionStorageError);
    persistenceMonitor.recordStorageOperation('sessionStorage', false);
  }
  
  return persistedSuccessfully;
};

/**
 * Toggle favorite status for a project and persist changes
 * @param {string} projectId - ID of the project to toggle
 * @param {Array} projects - Current array of projects
 * @returns {Promise<Object>} - Updated project data
 */
export const toggleProjectFavorite = async (projectId, projects) => {
  if (!projectId || !projects || !Array.isArray(projects)) {
    return { success: false, projects };
  }
  
  try {
    // Find and update the project
    const updatedProjects = projects.map(project => {
      if (project.id === projectId) {
        return { ...project, favorite: !project.favorite };
      }
      return project;
    });
    
    // Persist changes to all storage methods
    await persistProjects(updatedProjects);
    
    // Try to update just the specific project in IndexedDB for efficiency
    try {
      const indexedDBService = await getIndexedDBService();
      if (indexedDBService) {
        const targetProject = updatedProjects.find(p => p.id === projectId);
        if (targetProject) {
          await indexedDBService.updateProject(targetProject);
        }
      }
    } catch (e) {
      console.warn('Failed to update individual project in IndexedDB:', e);
      // Non-critical error, we already saved all projects above
    }
    
    return { success: true, projects: updatedProjects };
  } catch (error) {
    console.error('Failed to toggle project favorite:', error);
    return { success: false, projects, error: error.message };
  }
};

/**
 * Delete a project from storage
 * @param {string} projectId - ID of the project to delete
 * @param {Array} projects - Current array of projects
 * @returns {Promise<Object>} - Updated project data
 */
export const deleteProject = async (projectId, projects) => {
  if (!projectId || !projects || !Array.isArray(projects)) {
    return { success: false, projects };
  }
  
  try {
    // Remove the project from the array
    const updatedProjects = projects.filter(project => project.id !== projectId);
    
    // Persist changes to all storage methods
    await persistProjects(updatedProjects);
    
    // Try to delete the specific project from IndexedDB
    try {
      const indexedDBService = await getIndexedDBService();
      if (indexedDBService) {
        await indexedDBService.deleteProject(projectId);
      }
    } catch (e) {
      console.warn('Failed to delete individual project from IndexedDB:', e);
      // Non-critical error, we already saved updated projects list above
    }
    
    return { success: true, projects: updatedProjects };
  } catch (error) {
    console.error('Failed to delete project:', error);
    return { success: false, projects, error: error.message };
  }
};

/**
 * Get persistence monitoring statistics
 * @returns {Object} - Statistics and diagnostic information
 */
export const getPersistenceStatistics = () => {
  return persistenceMonitor.getDiagnosticReport();
};

/**
 * Reset persistence monitoring statistics
 */
export const resetPersistenceStatistics = () => {
  return persistenceMonitor.resetStatistics();
};

export default {
  fetchProjects,
  persistProjects,
  searchProjects,
  toggleProjectFavorite,
  deleteProject,
  filterProjects,
  checkApiHealth,
  getPersistenceStatistics,
  resetPersistenceStatistics,
  DEMO_PROJECTS
};

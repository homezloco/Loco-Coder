# Database Schema Management Guide

This guide explains how to manage database schemas in the WindSurf backend using SQLAlchemy and Alembic.

## Overview

The WindSurf backend uses:
- **SQLAlchemy**: ORM for database interactions
- **Alembic**: Database migration tool
- **Pydantic**: Data validation for API schemas

This combination provides type safety, validation, and reliable schema migrations.

## Directory Structure

```
backend/
├── schemas/
│   ├── models.py             # SQLAlchemy models
│   ├── database.py           # Database connection
│   ├── alembic.ini           # Alembic config
│   └── migrations/           # Migration scripts
│       ├── env.py            # Migration environment
│       ├── script.py.mako    # Migration template
│       └── versions/         # Generated migrations
├── api/
│   ├── schemas.py            # Pydantic models
│   ├── services/             # Business logic
│   └── routes/               # API endpoints
└── tests/                    # E2E tests
```

## SQLAlchemy Models

SQLAlchemy models are defined in `backend/schemas/models.py`. These models represent database tables and relationships.

### Model Example

```python
from sqlalchemy import Column, String, Boolean, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(String, primary_key=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    password_hash = Column(String)
    is_active = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    organization_id = Column(String, ForeignKey("organizations.id"), nullable=True)
    
    # Relationships
    organization = relationship("Organization", back_populates="users")
    projects = relationship("Project", back_populates="owner")
```

## Database Connection

Database connection is managed in `backend/schemas/database.py`. This module provides:

1. Async database engine
2. Session management
3. Database initialization

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

# Database URL from environment or default
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./data/windsurf.db")

# Create engine
engine = create_async_engine(
    DATABASE_URL,
    echo=False,
    future=True,
    connect_args={"check_same_thread": False} if DATABASE_URL.startswith("sqlite") else {}
)

# Session factory
AsyncSessionLocal = sessionmaker(
    engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)

# Get database session
async def get_db():
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()
```

## Alembic Migrations

Alembic is used for database migrations. It tracks changes to your SQLAlchemy models and generates migration scripts.

### Initial Setup

Alembic is already configured in the project. The configuration files are:

- `backend/schemas/alembic.ini`: Main configuration
- `backend/schemas/migrations/env.py`: Environment configuration
- `backend/schemas/migrations/script.py.mako`: Migration script template

### Creating Migrations

To create a new migration:

```bash
# Navigate to the backend directory
cd backend

# Create a new migration
alembic revision --autogenerate -m "Description of changes"
```

This will:
1. Compare your SQLAlchemy models to the current database schema
2. Generate a migration script in `backend/schemas/migrations/versions/`

### Applying Migrations

To apply migrations:

```bash
# Apply all pending migrations
alembic upgrade head

# Apply specific migration
alembic upgrade <revision>

# Revert to previous migration
alembic downgrade -1

# Revert to specific migration
alembic downgrade <revision>
```

### Migration Best Practices

1. **Small, focused migrations**: Create migrations for specific changes rather than large batches
2. **Review autogenerated migrations**: Always review and test before applying
3. **Version control**: Commit migration scripts to version control
4. **Test migrations**: Test migrations in development before production
5. **Backup database**: Always backup production database before migrations

## Working with Database in Services

Services interact with the database using SQLAlchemy async sessions:

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

class UserService:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_user(self, user_id: str):
        query = select(UserModel).where(UserModel.id == user_id)
        result = await self.db.execute(query)
        return result.scalar_one_or_none()
    
    async def create_user(self, user_data):
        db_user = UserModel(**user_data)
        self.db.add(db_user)
        await self.db.commit()
        await self.db.refresh(db_user)
        return db_user
```

## Database Fallbacks

For robustness, the WindSurf backend implements several database fallbacks:

1. **Connection retries**: Using tenacity for retry logic
2. **Database type fallback**: Supporting both PostgreSQL and SQLite
3. **Read-only mode**: When database writes fail

### Connection Retry Example

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(stop=stop_after_attempt(5), wait=wait_exponential(multiplier=1, min=1, max=10))
async def execute_with_retry(session, query):
    return await session.execute(query)
```

### Database Type Fallback

The application can switch between database types based on configuration:

```python
# Primary database (PostgreSQL)
PRIMARY_DATABASE_URL = os.getenv("DATABASE_URL")

# Fallback database (SQLite)
FALLBACK_DATABASE_URL = "sqlite+aiosqlite:///./data/fallback.db"

# Try primary database first, fall back to SQLite
try:
    engine = create_async_engine(PRIMARY_DATABASE_URL)
    # Test connection
    async with engine.begin() as conn:
        await conn.execute(text("SELECT 1"))
except Exception as e:
    logger.warning(f"Primary database connection failed: {e}")
    logger.info("Falling back to SQLite database")
    engine = create_async_engine(
        FALLBACK_DATABASE_URL,
        connect_args={"check_same_thread": False}
    )
```

## Testing Database Code

The testing framework uses an in-memory SQLite database:

```python
# Test database
TEST_DATABASE_URL = "sqlite+aiosqlite:///:memory:"
test_engine = create_async_engine(TEST_DATABASE_URL)

# Test session factory
TestingSessionLocal = sessionmaker(
    test_engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)

# Test dependency override
async def override_get_db():
    async with TestingSessionLocal() as session:
        yield session

# Apply in tests
app.dependency_overrides[get_db] = override_get_db
```

## Common Tasks

### Adding a New Model

1. Add the model class to `backend/schemas/models.py`
2. Create relationships with other models
3. Generate a migration with `alembic revision --autogenerate -m "Add new model"`
4. Apply the migration with `alembic upgrade head`
5. Create corresponding Pydantic schemas in `backend/api/schemas.py`

### Modifying an Existing Model

1. Update the model in `backend/schemas/models.py`
2. Generate a migration with `alembic revision --autogenerate -m "Update model"`
3. Review the generated migration script
4. Apply the migration with `alembic upgrade head`
5. Update corresponding Pydantic schemas

### Database Initialization

The database is initialized on application startup:

```python
@app.on_event("startup")
async def startup_event():
    await init_db()

async def init_db():
    from .models import Base
    
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
```

## Troubleshooting

### Migration Issues

- **"Target database is not up to date"**: Run `alembic upgrade head` first
- **Conflicts in migration**: Manually edit the migration script or create a new one
- **"Can't locate revision"**: Check if you're in the correct directory or if the revision exists

### Connection Issues

- Check database URL format
- Verify database server is running
- Check network connectivity
- Verify credentials

### Performance Issues

- Use indexing for frequently queried columns
- Use async session properly (don't block the event loop)
- Optimize queries with proper joins
- Consider using SQLAlchemy's query optimization features

## Conclusion

This guide covers the basics of database schema management with SQLAlchemy and Alembic in the WindSurf backend. For more detailed information, refer to the official documentation:

- [SQLAlchemy Documentation](https://docs.sqlalchemy.org/)
- [Alembic Documentation](https://alembic.sqlalchemy.org/)
- [FastAPI with SQLAlchemy](https://fastapi.tiangolo.com/tutorial/sql-databases/)

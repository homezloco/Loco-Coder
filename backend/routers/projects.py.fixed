"""
Project Management API Endpoints
"""
from fastapi import APIRouter, Depends, HTTPException, status, Body, Response, Request
from fastapi.responses import JSONResponse, Response
from typing import List, Optional, Dict, Any
import logging
from datetime import datetime
import os
import tempfile
import zipfile
import io

# Import project management components
from project_management import ProjectManager, ProjectCreate, Project, ProjectUpdate, project_manager
from project_management.models import CodeGenerationRequest, CodeGenerationResponse
from user_management import get_current_active_user, User
from pydantic import BaseModel
from typing import Dict, Any

# Define a model for code download requests
class CodeDownloadRequest(BaseModel):
    code: Dict[str, str]
    techStack: str = "python-fastapi"

# Initialize logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create router without prefix since it's added in main.py
router = APIRouter(tags=["projects"])

# Use the singleton project_manager instance from the module
# No need to reassign it to itself

@router.get("", response_model=List[Project])
@router.get("/", response_model=List[Project])  # Support both with and without trailing slash
async def list_projects(
    skip: int = 0,
    limit: int = 100,
    current_user: User = Depends(get_current_active_user)
):
    """
    List all projects for the current user
    """
    try:
        logger.info(f"Listing projects for user {current_user.id} with org {getattr(current_user, 'organization_id', 'None')}")
        
        # Get projects for the current user
        projects = await project_manager.get_projects_for_user(
            user_id=str(current_user.id),
            organization_id=str(current_user.organization_id) if hasattr(current_user, 'organization_id') and current_user.organization_id else None
        )
        
        logger.info(f"Found {len(projects)} projects")
        
        # If no projects found, create a default one for testing
        if not projects and skip == 0 and limit > 0:
            logger.info("No projects found, creating a default project")
            try:
                default_project = await project_manager.create_project(
                    project_data={
                        "name": "My First Project",
                        "description": "A sample project to get you started",
                        "project_type": "web"
                    },
                    owner_id=str(current_user.id)
                )
                projects = [default_project]
            except Exception as e:
                logger.error(f"Error creating default project: {str(e)}")
        
        # Apply pagination
        result = projects[skip:skip + limit]
        logger.info(f"Returning {len(result)} projects after pagination")
        return result
        
    except Exception as e:
        logger.error(f"Error listing projects: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to fetch projects: {str(e)}"
        )

@router.post("/", response_model=Project, status_code=status.HTTP_201_CREATED)
async def create_project(
    project: ProjectCreate,
    current_user: User = Depends(get_current_active_user)
):
    """
    Create a new project
    """
    try:
        # Add owner and organization info
        project_data = project.dict()
        project_data["owner_id"] = str(current_user.id)
        if current_user.organization_id:
            project_data["organization_id"] = str(current_user.organization_id)
            
        # Create the project
        new_project = await project_manager.create_project(
            project_data=project_data,
            owner_id=str(current_user.id)
        )
        return new_project
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error creating project: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create project"
        )

@router.get("/{project_id}", response_model=Project)
async def get_project(
    project_id: str,
    current_user: User = Depends(get_current_active_user)
):
    """
    Get a specific project by ID
    """
    try:
        # Get the project by ID
        project = await project_manager.get_project(project_id=project_id)
        if not project:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Project not found"
            )
            
        # Check if user has access to the project
        if not await project_manager.can_access_project(
            project_id=project_id,
            user_id=str(current_user.id),
            organization_id=str(current_user.organization_id) if hasattr(current_user, 'organization_id') and current_user.organization_id else None
        ):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to access this project"
            )
            
        return project
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching project {project_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to fetch project"
        )

@router.put("/{project_id}", response_model=Project)
async def update_project(
    project_id: str,
    project_update: ProjectUpdate,
    current_user: User = Depends(get_current_active_user)
):
    """
    Update a project
    """
    try:
        # Check if user has access to the project
        if not await project_manager.can_access_project(
            project_id=project_id,
            user_id=str(current_user.id),
            organization_id=str(current_user.organization_id) if hasattr(current_user, 'organization_id') and current_user.organization_id else None
        ):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to update this project"
            )
            
        # Update the project
        updated_project = await project_manager.update_project(
            project_id=project_id,
            project_data=project_update.dict(exclude_unset=True),
            user_id=str(current_user.id)
        )
        return updated_project
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error updating project {project_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update project"
        )

@router.delete("/{project_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_project(
    project_id: str,
    current_user: User = Depends(get_current_active_user)
):
    """
    Delete a project
    """
    try:
        # Check if user has access to the project
        if not await project_manager.can_access_project(
            project_id=project_id,
            user_id=str(current_user.id),
            organization_id=str(current_user.organization_id) if hasattr(current_user, 'organization_id') and current_user.organization_id else None
        ):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to delete this project"
            )
            
        # Delete the project
        success = await project_manager.delete_project(
            project_id=project_id,
            user_id=str(current_user.id)
        )
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Project not found"
            )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting project {project_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete project"
        )

@router.post("/{project_id}/download-code", response_class=Response)
async def download_code(
    project_id: str,
    download_request: CodeDownloadRequest = Body(...),
    current_user: User = Depends(get_current_active_user)
):
    """
    Download generated code as a ZIP file
    """
    try:
        # Check if user has access to the project
        if not await project_manager.can_access_project(
            project_id=project_id,
            user_id=str(current_user.id),
            organization_id=str(current_user.organization_id) if hasattr(current_user, 'organization_id') and current_user.organization_id else None
        ):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to download code for this project"
            )
        
        # Extract code from request model
        code = download_request.code
        tech_stack = download_request.techStack
        
        if not code:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No code provided for download"
            )
        
        # Create a temporary directory to store the files
        with tempfile.TemporaryDirectory() as temp_dir:
            # Write each file to the temporary directory
            for file_path, file_content in code.items():
                # Create subdirectories if needed
                full_path = os.path.join(temp_dir, file_path)
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                
                # Write the file
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(file_content)
            
            # Create a ZIP file in memory
            memory_file = io.BytesIO()
            with zipfile.ZipFile(memory_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for root, _, files in os.walk(temp_dir):
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, temp_dir)
                        zipf.write(file_path, arcname)
            
            # Reset the file pointer to the beginning
            memory_file.seek(0)
            
            # Create a response with the ZIP file
            response = Response(
                content=memory_file.getvalue(),
                media_type="application/zip"
            )
            response.headers["Content-Disposition"] = f"attachment; filename={project_id}-{tech_stack}.zip"
            
            return response
    except Exception as e:
        logger.error(f"Error downloading code for project {project_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to download code: {str(e)}"
        )

@router.post("/{project_id}/generate-code", response_model=CodeGenerationResponse)
async def generate_code(
    project_id: str,
    code_request: CodeGenerationRequest = Body(..., embed=True),  # Use embed=True to expect a field named 'code_request'
    current_user: User = Depends(get_current_active_user)
):
    """
    Generate code for a project based on ERD, API design, and test data
    
    The request body should contain a 'code_request' field with the CodeGenerationRequest data.
    """
    try:
        # Log received data
        logger.info(f"Received CodeGenerationRequest for project {project_id}")
        
        # Verify that the project_id in the URL matches the one in the request
        if code_request.project_id != project_id:
            logger.warning(f"Project ID mismatch: URL={project_id}, Request={code_request.project_id}")
            # Override with the URL project_id for consistency
            code_request.project_id = project_id
            logger.info(f"Using project_id from URL: {project_id}")
            
        # Check if user has access to the project
        if not await project_manager.can_access_project(
            project_id=project_id,
            user_id=str(current_user.id),
            organization_id=str(current_user.organization_id) if hasattr(current_user, 'organization_id') and current_user.organization_id else None
        ):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to generate code for this project"
            )
            
        # Generate code
        result = await project_manager.generate_code(
            code_gen_request=code_request,
            user_id=str(current_user.id)
        )
        
        # Check if generation was successful
        if hasattr(result, 'success') and not result.success:
            logger.error(f"Code generation failed: {getattr(result, 'message', 'Unknown error')}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Code generation failed: {getattr(result, 'message', 'Unknown error')}"
            )
        elif isinstance(result, dict) and not result.get('success', False):
            logger.error(f"Code generation failed: {result.get('message', 'Unknown error')}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Code generation failed: {result.get('message', 'Unknown error')}"
            )
            
        return result
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating code for project {project_id}: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate code: {str(e)}"
        )
